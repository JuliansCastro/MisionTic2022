# -*- coding: utf-8 -*-
"""Retos Ciclo I - MisionTIC2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z3bA8tV6lYQAevQ1t8sUhioqk9XAV-08

#Solución de los retos

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
inlineMath: [['$','$'], ['\\(','\\)']],
processEscapes: true},
jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
TeX: {
extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
equationNumbers: {
autoNumber: "AMS"
}
}
});
</script>

***Uso de*** $\LaTeX$

How to use [LaTex](http://flennerhag.com/2017-01-14-latex/) in [Markdown](https://www.markdownguide.org/extended-syntax/)
"""

# Commented out IPython magic to ensure Python compatibility.
# %reset

"""##Reto 1.Grupo P80: ¡El legado del escudo del Capitán América!

En una escena eliminada de ***Falcon and The Winter Soldier***, Sam, Bucky y John Walker decidieron lanzar el escudo del Capitán América y ver qué tan lejos podría llegar si necesitaran atacar de lejos a alguien de los Flag Smashers. El escudo de Bucky fue el que más lejos llegó, su lanzamiento –luego de suprimir cuatro (4) metros- superó el doble de metros recorridos por el escudo de Sam. Mientras tanto, John Walker se siente frustrado porque la distancia que recorrió su lanzamiento es cinco veces menor que la suma de las distancias de Sam y Bucky.

Adicionalmente, el gobierno de Estados Unidos decidió categorizar estos lanzamientos. Si el escudo recorrió entre 0 y 20 metros, está en categoría **uno**, si está entre 21 y 30 metros en categoría **dos**, entre 31 y 50 metros se cataloga como categoría **tres**, y, por último, la categoría **cuatro** si es superior a los 50 metros. Esto con el fin de poder considerar la fuerza de nuestros héroes en el campo de batalla.

Elabore un programa que, dado el lanzamiento de Sam, muestre en la primera línea los metros recorridos para los lanzamientos de Sam, Bucky y John, separados por un espacio. Luego, en la segunda línea imprima en qué categoría quedó el lanzamiento de John Walker.

**Entrada**

La entrada es un número entero que representa la distancia en la que llegó el escudo lanzado por Sam.

**Salida**

Tres números enteros separados por un espacio que simbolizan las distancias de los lanzamientos de Sam, Bucky y John Walker. En la siguiente línea en letras la categoría del lanzamiento de John Walker.

**Ejemplo**

| Entrada | Salida          |
| :------ | :-------------- |
| 14      | 14 32 9 <br> uno|
"""

sam = int(input('Ingrese la distancia (m) alcanzada por Sam: '))
bucky = 2*sam + 4
john_walker = int((bucky/2 + 2*sam +2) / 5)
 
def categoria_lanzamiento(john_w):
  if john_w >=0 and john_w < 21:
    return 'uno'
  elif john_w > 20 and john_w < 31:
    return 'dos'
  elif john_w > 30 and john_w < 51:
    return 'tres'
  elif john_w > 50:
    return 'cuatro'
 
print(f'{sam} {bucky} {john_walker}')
print(categoria_lanzamiento(john_walker))

sam = 10
pedro = 9
john = 32
def categoria (metros_john):
  if metros_john in range(0,21):
    return 'uno'
  elif metros_john in range(22,30):
    return 'dos'
  elif metros_john in range(31,50):
    return 'tres'
 
print(f'{john} {sam} {pedro}')
print(categoria(john))

"""##Reto 2: Grupo P80

El gobierno de los Estados Unidos ha decidido implantar chips en dos presos de Rikers Island, Nueva York: **Frank Castle (Punisher) y Wilson Fisk (Kingpin)**, con el fin de controlar sus pasos. Una noche, Fisk intentó realizar un motín para tomar control de la prisión. Se sabe que Castle es un antihéroe que no permitiría que Fisk se saliera con la suya.

En otro lugar, un integrante del gobierno quiere saber quién ganó la batalla, ya que los chips contienen la información de los ataques que cada uno propinó y recibió. Sin embargo, un error de los chips causó que se interpretaran acciones de disputa de otros presos, por lo que solo cuenta con la fiabilidad de los ataques que usaron Castle y Fisk. Para saber qué sucedió, decide tomar cada ataque, asignarles una letra dentro del alfabeto inglés, y formar cadenas de caracteres que representan sus movimientos.

De este modo, obtiene tres cadenas: una cadena para Castle, otra para Fisk, y la última representa las arremetidas de todos los presos. Luego, revisa cada choque, verifica si pertenece a los ataques de los dos presos y añade un punto a Castle o a Fisk según corresponda. Al final de cada revisión, añade la letra **C** si Castle tiene más puntos acumulados durante ese choque (y los anteriores) respecto a Fisk, la letra **F** si es Fisk quién lleva más que Castle, o un guion (-) si Fisk y Castle llevan los mismos puntos acumulados. Por último, escribe una cadena de caracteres que representa quién llevaba más puntos al final de cada choque.

***Ejemplo***

·        Cadena de Castle: AQW

·        Cadena de Fisk: APX

·        Cadena de ataques presos: PXAQWGBW


| Ataques presos     | ¿Es ataque de Castle? | ¿Es ataque de Fisk? | Ganador por puntos <br> acumulados en choque |
| :-: | :-: | :-: | :-: |
|  P  |  0  |  1  |  F  |
|  X  |  0  |  1  |  F  |
|  A  |  1  |  1  |  F  |
|  Q  |  1  |  0  |  F  |
|  W  |  1  |  0  |  -  |
|  G  |  0  |  0  |  -  |
|  B  |  0  |  0  |  -  |
|  W  |  1  |  0  |  C  |


· Cadena final: FFFF---C



**Entrada**

Tres cadenas de caracteres. La primera representa los ataques de Castle, la segunda los ataques de Fisk, y la tercera la información de ataques que han sido capturados en los chips.

**Salida**

Una cadena de caracteres con los símbolos “C” (que representa a Frank Castle), “W” (Wilson Fisk) y “-”, que muestra quién va ganando al procesar cada ataque recibido.

| Entrada                                    | Salida             |
| :----------------------------------------: | :----------------: |
| BWOCVT <br> JOIGED <br> YNYJAVOLBQKNYKSZYG | ---WW---CCCCCCCCC- |
"""

castle = input('Ingrese cadena de Castle: ')
fisk = input('Ingrese cadena de Fisk: ')
other_prisoners = input('Ingrese cadena de los otros presos: ')

#castle, fisk, other_prisoners = 'BWOCVT', 'JOIGED', 'YNYJAVOLBQKNYKSZYG'

def battle_winner(castle_attack, fisk_attack, other_attacks):
  winner_string = ''
  accumulator_c, accumulator_f = 0, 0
  for letter in other_attacks:
    idx_c = castle_attack.find(letter)
    idx_f = fisk_attack.find(letter)

    if letter == castle_attack[idx_c]:
      accumulator_c +=1

    if letter == fisk_attack[idx_f]:
      accumulator_f += 1

    if accumulator_c == accumulator_f:
      winner_string += '-'
    elif accumulator_c < accumulator_f:
      winner_string += 'F'
    else:
      winner_string += 'C'

  return winner_string


print(battle_winner(castle, fisk, other_prisoners))

import json

articulos_supermercado = input('Ingrese lista supermecado: ')
lista_crhistian = input('Ingrese la lista cristian: ').split(' ')
articulos_supermercado = json.loads(articulos_supermercado)

puntos = 0
lista_productos = ''

for elemento in lista_crhistian:
    if elemento in articulos_supermercado:
        lista_productos = lista_productos + elemento + ' '
        puntos = puntos + articulos_supermercado[elemento]

print(puntos)
print(lista_productos)

print(type(True))
x=range(11,20,2)
print(x)

def valor_absoluto(x):
    valor = x if x>=0 else -x
    return valor
 
print(valor_absoluto(-1))

"""## Reto 3: Grupo P80

En un torneo virtual de la oficina, Michael desea conocer las rachas que ha tenido en Mario Kart, en el que al final de cada carrera puede terminar en las posiciones 1 a 8. Michael ha anotado en qué posición ha quedado cada vez, y desea procesar estos resultados para ver su avance de forma simplificada. Al final obtiene dos listados, el primero en el que agrega una nueva posición solo si esta cambia y la segunda la cantidad de veces que ocurrió esa posición de forma consecutiva.

 

***Ejemplo:***

**Entrada**:

4 4 5 4 3 3 3

 

**Salida**:

4 5 4 3

2 1 1 3

 

Michael agregó la posición 4, que se repitió dos veces.

Luego agregó la posición 5, que solo apareció una vez.

Agregó como nueva posición el 4° lugar, que sucedió una vez en ese instante.

Finalmente, aparece que terminó en la posición 3, que ocurrió 3 veces consecutivas.

***Entrada***

Listado de posiciones en los que llegó en cada carrera, separadas por un espacio.

 
***Salida***

Dos líneas: la primera línea representa las posiciones que ha obtenido separados por un espacio, y la segunda línea la cantidad de veces que se obtuvo esa posición de forma consecutiva.

| Entrada                   |        Salida            |
| :------------------------ | :----------------------- |
| 7 6 6 6 2 6 6 6 6 5 5 5 5 | 7 6 2 6 5 <br> 1 3 1 4 4 |
"""

#streaks_entry = '7 6 6 6 2 6 6 6 6 5 5 5 5'
streaks_entry = '4 4 5 4 3 3 3' 
#streaks_entry = input('Ingrese cadena de rachas separada por un espacio: ')
 
 
def process_results(streaks):
  streaks = streaks.split(' ')
  counter, previous_streak = 0, ''
  positions, position_frequency = [], []
 
  for streak in streaks: 
    if positions == []:
      positions.append(streak)
      previous_streak = streak
 
    if streak != previous_streak:
      positions.append(streak)
      position_frequency.append(str(counter))
      previous_streak = streak
      counter = 0
 
    if streak == previous_streak:
      counter += 1
    
  
  
  print(' '.join(positions))
  print(' '.join(position_frequency))
 
 
process_results(streaks_entry)

#lista_inicial = '4 4 5 4 3 3 3'
lista_inicial = '1 2 2 3 3 3 4 4 4 4 5 5 5 5 5'
lista_inicial = lista_inicial.split(' ')

lista_resultado1, lista_resultado2 = [], []
contador = 1

for i in range(1, len(lista_inicial)):
  if (lista_inicial[i] != lista_inicial[i-1]):
    lista_resultado1.append(lista_inicial[i-1])

  if (lista_inicial[i] == lista_inicial[i-1]):
    contador += 1
  else:
    lista_resultado2.append(str(contador))
    contador = 1

lista_resultado1.append(lista_inicial[i])
lista_resultado2.append(str(contador))

print(' '.join(lista_resultado1))
print(' '.join(lista_resultado2))

def Resultados_Mario(Resul):
    Result = Resul.split(' ')
    Posiciones, cuenta, b = '', '', ''
    contador = 0
    
    for i in Result:
        if Posiciones == '':
            Posiciones += i
            b = i
        if i != b:
            Posiciones += i
            cuenta += str(contador)
            b = i
            contador = 0
        if i == b:
            contador += 1
            #print(contador)
    cuenta += str(contador)

    print(' '.join(Posiciones))
    print(' '.join(cuenta))


Resultados = '4 4 5 4 3 3 3' #'1 2 2 3 3 3 4 4 4 4 5 5 5 5 5'   #str(input())
Resultados_Mario(Resultados)

"""https://pythontutor.com/

3013220021   cel profe  Carlos
"""

#Floricelda Pete Yoja 
#cc. 1062085358

"""##Reto 4: Grupo P80

Christian Nodal necesita ir a mercar y su padre le ha encargado una lista con los artículos a comprar. El supermercado al que él va tiene un programa de puntos por la compra de determinados productos, el cual está publicado en la entrada de la tienda. Christian desea conocer cuáles artículos de los que tiene en la lista están en el programa de puntos, y adicionalmente, cuántos puntos acumularía por los mismos. 

**Entrada**

La entrada consta de dos líneas. La primera línea contiene un diccionario en formato JSON con los productos que el supermercado ha dispuesto en su mercado de puntos, donde cada *producto* es una llave que contiene como valor *puntos*.  La segunda corresponde al listado de productos que se adquirirán en el supermercado, separados por un espacio. 

**Salida**

Dos líneas. La primera línea corresponde a los puntos acumulados de los productos de la lista de mercar que están en el programa de puntos. La segunda línea corresponde al listado de dichos productos, separados por un espacio. 

<br>

| **Entrada** | **Salida** |
| :---------- | :--------- |
| {"Carne": 64, "Garbanzo": 88, "Fruta": 54, "Lenteja": 94, "Verdura": 66} <br> Fruta Leche Papa Huevos Carne | 118 <br> Fruta Carne|
| {"Arroz": 77, "Frijol": 19, "Pescado": 68, "Verdura": 57, "Fruta": 41} <br> Huevos Carne Yogur Pollo Arroz | 77 <br> Arroz |
"""

import json

json_supermarket = input('Ingrese datos Json: ')
Christians_father_list = input('Ingrese lista de compras padres de Christian: ')

#json_supermarket = '{"Carne": 64, "Garbanzo": 88, "Fruta": 54, "Lenteja": 94, "Verdura": 66}'
#Christians_father_list = 'Fruta Leche Papa Huevos Carne'

#json_supermarket = '{"Arroz": 77, "Frijol": 19, "Pescado": 68, "Verdura": 57, "Fruta": 41}'
#Christians_father_list = 'Huevos Carne Yogur Pollo Arroz'

data_supermarket = json.loads(json_supermarket)
Christians_father_list = Christians_father_list.split(' ')

accumulated_points = 0
products_in_points_program = []

for product in Christians_father_list:
    if product in data_supermarket:
        products_in_points_program.append(product)
        accumulated_points += data_supermarket[product]


print(accumulated_points)
print(' '.join(products_in_points_program))

#claves = eval('')
#lista_mercado = 'Fruta Leche Papa Huevos Carne'
#lista_mercado = input('Ingrese lista mercado: ').split(' ')

claves = "{\"Carne\": 64, \"Garbanzo\": 88, \"Fruta\": 54, \"Lenteja\": 94, \"Verdura\": 66}" #@param {type:"string"}
claves = eval(claves)
lista_mercado = 'Fruta Leche Papa Huevos Carne' #@param {type:"string"}
lista_mercado = lista_mercado.split(' ')

b, c = 0, ''

for elemento in lista_mercado:
    if elemento in claves:
        c += elemento + " "
        b += claves[elemento]
print(b)
print(c)

"""##Reto 5: Grupo P80

*PokeTwo* es un bot de Discord que permite coleccionar Pokémon usando comandos de texto. En el servidor, necesitan un módulo en Python que permita realizar las siguientes operaciones sobre los Pokémon que cada usuario ha coleccionado:

 

1. ```obtener_todos(lista):``` dada una lista de Pokémon capturados, retorna una lista de todos los Pokémon sin repeticiones.

| **Entrada:** | **Resultado:** |
| :----------- | :------------- |
| ```['Pikachu', 'Meowth', 'Eevee', 'Bulbasaur', 'Pikachu', 'Eevee']``` | ```['Pikachu', 'Meowth', 'Eevee', 'Bulbasaur']```

 

2. ```obtener_coincidencia(posLista, pokemonLista, pokemonBuscado):``` Una lista de posiciones a revisar, una lista de Pokémon y el nombre de un Pokémon son recibidos como parámetros. Como salida, se debe devolver la lista de las posiciones en donde el nombre del Pokémon coincidió dentro de pokemonLista y que a su vez coincida en la posición dada en posLista.

| **Entrada de la función}** | **Resultado** |
| :------------------------- | :------------ |
| ```[0, 2, 3, 5, 6]``` <br> ```['Pikachu', 'Pichu', 'Raichu', 'Bulbasaur', 'Eevee', 'Meowth', 'Pikachu', 'Pikachu']``` <br> ```Pikachu``` | ```[0, 6]``` |

 <br>

3. ```obtener_pokemon_diferentes(pokemonUsuario1, pokemonUsuario2):``` se dan dos listas, las cuales representan listas de Pokémon capturados por dos usuarios diferentes. Se procesan ambas listas y retorna los Pokémon que no tenga el primer usuario.



| **Entrada de la función** | **Resultado** |
| :------------------------ | :------------ |
| ```['Pikachu', 'Meowth', 'Pichu']``` <br> ```['Raichu', 'Pikachu', 'Squirtle']``` | ```['Meowth', 'Pichu']``` |

 <br>

4. ```obtener_numero_intercambios(pokemonUsuario1, pokemonUsuario2):``` se dan dos listas, las cuales representan los Pokémon que pueden intercambiar dos usuarios. Retorna el número de intercambios posibles que pueden realizar.

| **Entrada de la función** | **Resultado** |
| :------------------------ | :------------ |
| ```['Pikachu', 'Bulbasaur', 'Charmander', 'Squirtle']``` <br> ```['Pikachu', 'Pichu', 'Raichu']``` | ```2``` |

<br>

**Entrada**

Este programa no necesita entrada y tampoco generará salida. Se requiere que el estudiante genere un archivo con el nombre ***pokemon_adicionales.py***. Adicionalmente, los nombres de las funciones deben ser iguales a los descritos en este documento.

**Puntuación**

Si los integrantes del servidor de Discord pueden importar el módulo se obtiene un punto. Para cada función que cumpla con la funcionalidad pedida se agrega un punto. Esto para un total de 5 puntos.
"""

def obtener_todos(lista): #1
    salida = []
    for elemento in lista:
        if elemento not in salida:
            salida.append(elemento)    
    return salida

'''
def obtener_coincidencia(posLista, pokemonLista, pokemonBuscado): #2
    salida = []
    for idx in range(len(pokemonLista)):
        if (pokemonLista[idx] == pokemonBuscado) and (idx in posLista):
            salida.append(idx)   
    return salida
'''

def obtener_coincidencia(posLista, pokemonLista, pokemonBuscado):
    r = []
    for posicion in posLista:
        if posicion < len(pokemonLista):
            if pokemonBuscado in pokemonLista[posicion]:
                r.append(posicion)
        else:
            break
    return r


def obtener_pokemon_diferentes(pokemonUsuario1, pokemonUsuario2):  #3
    salida = []
    for pokemon in pokemonUsuario1:
        if pokemon not in pokemonUsuario2:
            salida.append(pokemon)
    return salida


def obtener_numero_intercambios(pokemonUsuario1, pokemonUsuario2): #4
    if len(pokemonUsuario2) <= len(pokemonUsuario1):
        return len(obtener_pokemon_diferentes(pokemonUsuario2, pokemonUsuario1))
    else:
        return len(obtener_pokemon_diferentes(pokemonUsuario1, pokemonUsuario2))

# Commented out IPython magic to ensure Python compatibility.
# %reset

"""####Pruebas reto 5"""

if obtener_todos(['Pikachu', 'Meowth', 'Eevee', 'Bulbasaur', 'Pikachu', 'Eevee']) == ['Pikachu', 'Meowth', 'Eevee', 'Bulbasaur']:
    print('Función 1: Passed test')
else:
    print('Función 1: Failed test')


if obtener_coincidencia([0, 2, 3, 5, 6, 8],
                     ['Pikachu', 'Pichu', 'Raichu', 'Bulbasaur', 'Eevee', 'Meowth', 'Pikachu', 'Pikachu'],
                     'Pikachu') == [0,6]:
                     print('Función 2: Passed test')
else:
    print('Función 2: Failed test')
    print(obtener_coincidencia([0, 2, 3, 5, 6, 8],
                     ['Pikachu', 'Pichu', 'Raichu', 'Bulbasaur', 'Eevee', 'Meowth', 'Pikachu', 'Pikachu'],
                     'Pikachu'))


if obtener_pokemon_diferentes(['Pikachu', 'Meowth', 'Pichu'],
                           ['Raichu', 'Pikachu', 'Squirtle']) == ['Meowth', 'Pichu']:
                           print('Función 3: Passed test')
else:
    print('Función 3: Failed test',end='')
    print(' ',obtener_pokemon_diferentes(['Pikachu', 'Meowth', 'Pichu'],
                           ['Raichu', 'Pikachu', 'Squirtle']))


if obtener_numero_intercambios(['Pikachu', 'Bulbasaur', 'Charmander', 'Squirtle'],
                               ['Pikachu', 'Pichu', 'Raichu']) == 2:
                               print('Función 4: Passed test\n\n')
else:
    print('Función 4: Failed test')

"""[Cómo encontrar el índice de un artículo en la lista de Python](https://www.delftstack.com/es/howto/python/how-to-find-the-index-of-an-element-in-a-list-in-python/)

## Nota final de los retos
"""

#[R1, R2, R3, R4, R5, Ingles]
notas_parciales = [5, 5, 5, 5, 5, 4.45]
pesos = [0.1, 0.1, 0.2, 0.2, 0.2, 0.2]

nota_final, idx = 0.0, 0
for nota in notas_parciales:
    nota_final += nota*pesos[idx]
    idx +=1
    

print(f'Nota final: {nota_final:0.2f}')

lista =['Pikachu', 'Meowth', 'Eevee', 'Bulbasaur', 'Pikachu', 'Eevee']
lista_sin_repetidos = set(lista)
print(lista)
print(sorted(lista_sin_repetidos))
print(lista == sorted(lista_sin_repetidos))

if 'al' in 'la altura':
    print('yes')
else:
    print('no')